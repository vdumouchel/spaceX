"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/*
 This file just manages the database connection and provides a query method
 */
const pg = require("pg"); // or native libpq bindings
// const pg = require("pg/native");


module.exports = (connection, log = console.error) => {
  const isExternalClient = connection instanceof pg.Client;
  let clientActive = false;
  const client = isExternalClient ? connection : new pg.Client(connection);
  const beforeCloseListeners = [];

  const createConnection = () => new Promise((resolve, reject) => clientActive || isExternalClient ? resolve() : client.connect(err => {
    if (err) {
      log("could not connect to postgres", err);
      return reject(err);
    }

    clientActive = true;
    return resolve();
  }));

  const query =
  /*#__PURE__*/
  function () {
    var _ref = _asyncToGenerator(function* (...args) {
      yield createConnection();

      try {
        return yield client.query(...args);
      } catch (err) {
        const message = err.message,
              position = err.position;
        const string = args[0].text || args[0];

        if (message && position >= 1) {
          const endLineWrapIndexOf = string.indexOf("\n", position);
          const endLineWrapPos = endLineWrapIndexOf >= 0 ? endLineWrapIndexOf : string.length;
          const stringStart = string.substring(0, endLineWrapPos);
          const stringEnd = string.substr(endLineWrapPos);
          const startLineWrapPos = stringStart.lastIndexOf("\n") + 1;
          const padding = " ".repeat(position - startLineWrapPos - 1);
          log(`Error executing:
${stringStart}
${padding}^^^^${stringEnd}

${message}
`);
        } else {
          log(`Error executing:
${string}
${err}
`);
        }

        throw err;
      }
    });

    return function query() {
      return _ref.apply(this, arguments);
    };
  }();

  const select =
  /*#__PURE__*/
  function () {
    var _ref2 = _asyncToGenerator(function* (...args) {
      const _ref3 = yield query(...args),
            rows = _ref3.rows;

      return rows;
    });

    return function select() {
      return _ref2.apply(this, arguments);
    };
  }();

  const column =
  /*#__PURE__*/
  function () {
    var _ref4 = _asyncToGenerator(function* (columnName, ...args) {
      return (yield select(...args)).map(r => r[columnName]);
    });

    return function column(_x) {
      return _ref4.apply(this, arguments);
    };
  }();

  return {
    query,
    select,
    column,
    addBeforeCloseListener: listener => beforeCloseListeners.push(listener),
    close: function () {
      var _close = _asyncToGenerator(function* () {
        yield beforeCloseListeners.reduce((promise, listener) => promise.then(listener).catch(err => log(err.stack || err)), Promise.resolve());

        if (!isExternalClient) {
          clientActive = false;
          client.end();
        }
      });

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  };
};